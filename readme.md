# MiniKotlin

A library for generating JVM bytecode using a type-safe Kotlin DSL mini-language, or writing raw bytecode through a lightweight ASM wrapper.

---

## Features

|                                | What you actually get                                                                                         |
|--------------------------------|---------------------------------------------------------------------------------------------------------------|
| **Runtime class generation**   | Define JVM classes and lambdas using a Kotlin-based DSL.                                                      |
| **Programming DSL**            | A simple, but expressive language to generate bytecode at runtime, without touching bytecode directly.        |
| **ASM abstraction layer**      | Lower-level access to raw bytecode through structured wrappers.                                               |
| **Verifier (optional)**        | Lightweight runtime verifier for stack safety, variable usage, and label state, with optional debug metadata. |
| **Debug metadata**             | If enabled via verifier, line numbers and instruction traces are emitted for stack trace clarity.             |
| **Synthetic constant storage** | Static synthetic fields for embedding runtime values into generated classes.                                  |
| **No reflective invocation**   | Generated bytecode is standard JVM code, no reflection needed to execute it.                                  |


---

## Quick start

```kotlin
fun main() {
    // Build a lambda:  Iterator<Any> → ArrayList<Any>
    val transform = implLambdaMiniKt<(Iterator<Any>) -> ArrayList<Any>> {
        val iter = variable<Iterator<Any>>("arg0")            // 1 read the single argument
        val out  = call<ArrayList<Any>>(::ArrayList)           // 2️ new ArrayList<Any>()
                        .toVariable("result")

        iter.forEach {
            callNt2(ArrayList<Any>::add, out, it).exec()       // 3 out.add(it)
        }

        thisFun.return_(out)                                   // 4 return out
    }

    println(transform(listOf(1, 2, 3, 4).iterator()))          // → [1, 2, 3, 4]
}
```

Running that file prints:

```
[1, 2, 3, 4]
```

The entire function body – including the loop – is generated **at runtime** and verified before it ever hits the class‑loader.

This is how it looks as decompiled java:
```java
public final class lambdade27b617f86b4ad0a4835d21901bbe25 implements Function1 {
    public final Object invoke(Object arg1) {
        return invokeOF((Iterator)arg1);
    }

    private static final Object invokeOF(Iterator arg0) {
        ArrayList result = new ArrayList();

        while(arg0.hasNext()) {
            result.add(arg0.next());
        }

        return result;
    }
}
```

---

## Using bytecode directly

You can also write bytecode without any mini language. 
However, you can mix pure bytecode and MiniKotlin in the same runtime class.

```kotlin
val k = makeClass("someFib", ClassProperties.Default) implements FibCustom::class implements FibTest::class body {
    autoInit()

    private static final ofType(Int::class) method "fibB"("n" to TypeInfo.Kt(Int::class)) runs {
        val lessThanTwoLabel = label("lessThanTwo")
        iload(0, "n")
        dup()
        iconst_2()
        if_icmpge(lessThanTwoLabel)
        ireturn()

        labelPoint(lessThanTwoLabel)
        iconst_1()
        isub()
        invokestatic(ThisClass, "fibB", args(Int::class) returns Int::class)

        iload(0, "n")
        iconst_2()
        isub()
        invokestatic(ThisClass, "fibB", args(Int::class) returns Int::class)

        iadd()
        ireturn()
    }

    implOf(FibTest()::fib) runsMiniKt {
        val n = variableNt<Int>("n") // a parameter of the function, Nt here means that it is native type

        switch {
            case(n lessOrEq number(0)) {
                thisFun.return_(miniIntArray(number(0)))
            }
            case(n eq number(1)) {
                thisFun.return_(miniIntArrayOf(number(0)))
            }
        }

        val fibs = miniIntArray(n).toVariable("fibs")
        fibs[number(0)] = number(0)
        fibs[number(1)] = number(1)
        val counter = number(2).toVariable("counter")

        whileDo(counter lessThan fibs.size()) {
            fibs[counter] = fibs[counter - number(1)] + fibs[counter - number(2)]
            counter setTo counter + number(1)
        }

        thisFun.return_(fibs)
    }

    implOf(FibCustom::action) runs {
        iload(variable("n"))
        invokestatic(ThisClass, "fibB", args(Int::class) returns Int::class)

        ireturn()
    }
}
val r = k.result()
val ins = r.initAndGetAsInterface<FibCustom>()
```

## How to use it?

1. You can either clone the whole project. And build it locally.
2. Or you can just download far jars I compiled. They are located in releases

I will soon post it on maven local as well, so it would be easier.


### Limitations

* This is an experimental project – bugs are expected.
* Debug and variable tracking are not always reliable.
* Currently only interface impl is supported, classes are planned.
* Mixing primitive and boxed types may yield subtle issues. Always remember to use correct functions: Nt stands for native type
* The internal verifier is not a replacement for JVM verification – always test your code.
* No bytecode editing, only generation. Tho you can edit what you did generate, before it is written to class

## Contributions welcome

You can see more examples in [tests](src/test/kotlin) folder

Feel free to ask questions or report bugs.
