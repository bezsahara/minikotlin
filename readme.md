# MiniKotlin

A library for generating JVM bytecode using a type-safe Kotlin DSL mini-language, or writing raw bytecode through a lightweight ASM wrapper.

---

## Features

|                                   | What you actually get                                                                                                                                                   |
|-----------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Runtime class generation**      | Define JVM classes and lambdas using a Kotlin-based DSL.                                                                                                                |
| **Compile-time class generation** | You can use gradle plugin to easily generate classes at compile time (no need to create subprojects, everything is done in one project) [Example](#Using-Gradle-plugin) |
| **Programming DSL**               | A simple, but expressive language to generate bytecode at runtime, without touching bytecode directly.                                                                  |
| **ASM abstraction layer**         | Lower-level access to raw bytecode through structured wrappers.                                                                                                         |
| **Verifier (optional)**           | Lightweight runtime verifier for stack safety, variable usage, and label state, with optional debug metadata.                                                           |
| **Debug metadata**                | If enabled via verifier, line numbers and instruction traces are emitted for stack trace clarity.                                                                       |
| **Synthetic constant storage**    | Static synthetic fields for embedding runtime values into generated classes.                                                                                            |
| **No reflective invocation**      | Generated bytecode is standard JVM code, no reflection needed to execute it.                                                                                            |


---

## How to install

Until it is posted on maven, you can either clone the project and compile it yourself, or you can just download jars I already compiled. 
The JARs are in releases. There is also sources JAR if you want to see them when using your IDE.
You can download fat JAR (and optionally the sources, just put them in the same folder) 
and then in your gradle:
```kotlin
// in your build.gradle.kts
dependencies {
    implementation(files("path/to/MiniKotlin-1.0-SNAPSHOT-all.jar"))
}
```

### Gradle plugin

You can use Gradle plugin, that allows compile-time code generation. It is available on Gradle Plugin Portal.
Just add this to your build logic:
```kotlin
// in your build.gradle.kts
plugins {
    id("org.bezsahara.minikotlin")
}
```

---

## Quick start

```kotlin
fun main() {
    // Build a lambda:  Iterator<Any> → ArrayList<Any>
    val transform = implLambdaMiniKt<(Iterator<Any>) -> ArrayList<Any>> {
        val iter = variable<Iterator<Any>>("arg0")            // 1 read the single argument
        val out  = call<ArrayList<Any>>(::ArrayList)           // 2️ new ArrayList<Any>()
            .toVariable("result")

        iter.forEach {
            callNt2(ArrayList<Any>::add, out, it).exec()       // 3 out.add(it)
        }

        thisFun.return_(out)                                   // 4 return out
    }

    println(transform(listOf(1, 2, 3, 4).iterator()))          // → [1, 2, 3, 4]
}
```

Running that file prints:

```
[1, 2, 3, 4]
```

The entire function body – including the loop – is generated **at runtime** and verified before it ever hits the class‑loader.

This is how it looks as decompiled java:
```java
public final class lambdade27b617f86b4ad0a4835d21901bbe25 implements Function1 {
    public final Object invoke(Object arg1) {
        return invokeOF((Iterator)arg1);
    }

    private static final Object invokeOF(Iterator arg0) {
        ArrayList result = new ArrayList();

        while(arg0.hasNext()) {
            result.add(arg0.next());
        }

        return result;
    }
}
```

---

## Using bytecode directly

You can also write bytecode without any mini language.
However, you can mix pure bytecode and MiniKotlin in the same runtime class.

```kotlin
val k = makeClass("someFib", ClassProperties.Default) implements FibCustom::class implements FibTest::class body {
    autoInit()

    private static final ofType(Int::class) method "fibB"("n" to TypeInfo.Kt(Int::class)) runs {
        val lessThanTwoLabel = label("lessThanTwo")
        iload(0, "n")
        dup()
        iconst_2()
        if_icmpge(lessThanTwoLabel)
        ireturn()

        labelPoint(lessThanTwoLabel)
        iconst_1()
        isub()
        invokestatic(ThisClass, "fibB", args(Int::class) returns Int::class)

        iload(0, "n")
        iconst_2()
        isub()
        invokestatic(ThisClass, "fibB", args(Int::class) returns Int::class)

        iadd()
        ireturn()
    }

    implOf(FibTest()::fib) runsMiniKt {
        val n = variableNt<Int>("n") // a parameter of the function, Nt here means that it is native type

        switch {
            case(n lessOrEq number(0)) {
                thisFun.return_(miniIntArray(number(0)))
            }
            case(n eq number(1)) {
                thisFun.return_(miniIntArrayOf(number(0)))
            }
        }

        val fibs = miniIntArray(n).toVariable("fibs")
        fibs[number(0)] = number(0)
        fibs[number(1)] = number(1)
        val counter = number(2).toVariable("counter")

        whileDo(counter lessThan fibs.size()) {
            fibs[counter] = fibs[counter - number(1)] + fibs[counter - number(2)]
            counter setTo counter + number(1)
        }

        thisFun.return_(fibs)
    }

    implOf(FibCustom::action) runs {
        iload(variable("n"))
        invokestatic(ThisClass, "fibB", args(Int::class) returns Int::class)

        ireturn()
    }
}
val r = k.result()
val ins = r.initAndGetAsInterface<FibCustom>()
```

## Using Gradle plugin

As mentioned [earlier](#how-to-install), you can use the Gradle plugin for compile‑time code generation without adding extra modules or subprojects.
```kotlin
@MiniKotlinGenerator
class GenEverything() : MKGenerator() {
    override fun generateClass(): List<KBClass.Result> {
        val cl = makeClass("some/path/to/HelloWorld") body {
            autoInit()
            
            val f = public static ofType(TypeInfo.Float) field "some"

            static() runsMiniKt {
                f.setField(number(3f))
                return_()
            }

            public static final ofType(TypeInfo.String) method "saySomething"("what" to TypeInfo.String) runsMiniKt {
                return_(joinStringsOf(str("HelloWorld says: "), variable<String>("what")))
            }
        }

        return listOf(cl.result())
    }
}
```

Annotate a class with `@MiniKotlinGenerator` and implement `MKGenerator`.
After the first run of your program, the classes are generated automatically.
You can also trigger generation with the `generateMiniKotlin` Gradle task.

**How it works:**<br>
The Gradle task runs your classes with a special entry point, so your generation code can use all your project’s classes and dependencies.
**Important**: don’t reference the classes being generated inside the generator itself; this will cause errors.

**Generated output:**
1. **Stub classes** – committed to your source tree; these are part of your program.
2. **Implementations** – live in the build directory and can be regenerated or deleted at any time.

**How to configure the plugin:**
```kotlin
minikotlin {
    // MANUAL - wire tasks manually
    // AUTO - plugin wires generateMiniKotlin after classes
    // default is AUTO
    runMode = MiniKotlinRunMode.AUTO

    // Sets the path to stubs folder, set it outside the build folder.
    // default is <projectDir>/minikotlin-stubs
    stubFolder.set(project.layout.projectDirectory.dir("mk-custom-stubs"))

    // Sets the path to implementation folder.
    // default is <buildDir>/minikotlin-gen
    generateFolder.set(project.layout.buildDirectory.dir("mk-custom-gen"))
}
```

## Limitations

* This is an experimental project – bugs are expected.
* Debug and variable tracking are not always reliable.
* Currently only interface impl is supported, classes are planned.
* Mixing primitive and boxed types may yield subtle issues. Always remember to use correct functions: Nt stands for native type
* The internal verifier is not a replacement for JVM verification – always test your code.
* No bytecode editing, only generation. Tho you can edit what you did generate, before it is written to class

## Contributions welcome

You can see more examples in [tests](src/test/kotlin) folder

Feel free to ask questions or report bugs.
